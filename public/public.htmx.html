<!doctype html>
<html lang="fr">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Écran de projection - Résultats en direct">
  <title>Écran public — AG-VOTE</title>
  <link rel="stylesheet" href="/assets/css/design-system.css">
  <link rel="stylesheet" href="/assets/css/public.css">
</head>
<body class="projection-body">

<header class="projection-header">
  <div class="header-left">
    <span class="status-badge off" id="badge">hors seance</span>
    <span class="motion-counter" id="motionCounter" hidden>
      <span id="motionCounterText">— / —</span>
    </span>
    <span class="meeting-title" id="meeting_title">Aucune seance</span>
  </div>
  <div class="clock" id="clock">--:--</div>
</header>

<main class="projection-main">
  <!-- Motion title -->
  <section class="motion-section">
    <div class="motion-number" id="motion_number"></div>
    <h1 class="motion-title" id="motion_title">—</h1>
    <p class="motion-subtitle" id="motion_sub"></p>
  </section>

  <!-- Resolution text -->
  <div class="resolution-box" id="resolution_box">
    <div class="resolution-text" id="resolution_text"></div>
  </div>

  <!-- Waiting state -->
  <div class="waiting-state" id="waiting_state">
    <svg class="waiting-icon" viewBox="0 0 24 24" fill="none">
      <!-- Cadran -->
      <circle class="clock-face" cx="12" cy="12" r="10" stroke-width="1.5"/>
      <!-- Repères heures (12, 3, 6, 9) -->
      <line class="clock-face" x1="12" y1="3" x2="12" y2="5" stroke-width="1"/>
      <line class="clock-face" x1="21" y1="12" x2="19" y2="12" stroke-width="1"/>
      <line class="clock-face" x1="12" y1="21" x2="12" y2="19" stroke-width="1"/>
      <line class="clock-face" x1="3" y1="12" x2="5" y2="12" stroke-width="1"/>
      <!-- Aiguille des heures -->
      <line class="clock-hand clock-hand-hour" x1="12" y1="12" x2="12" y2="7"/>
      <!-- Aiguille des minutes -->
      <line class="clock-hand clock-hand-minute" x1="12" y1="12" x2="12" y2="5"/>
      <!-- Aiguille des secondes -->
      <line class="clock-hand clock-hand-second" x1="12" y1="12" x2="12" y2="4"/>
      <!-- Centre -->
      <circle cx="12" cy="12" r="1" fill="currentColor"/>
    </svg>
    <h3 class="waiting-title">En attente</h3>
    <p class="waiting-text">Aucune résolution ouverte</p>
  </div>

  <!-- Secret vote -->
  <div class="secret-block" id="secret_block">
    <div class="secret-icon">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
      </svg>
    </div>
    <h4 class="secret-title">Vote secret</h4>
    <p class="secret-text">Resultats affiches a la cloture</p>
    <div class="participation-bar">
      <div class="participation-fill" id="participation_bar" style="width: 0%;"></div>
    </div>
    <div class="participation-text"><span id="participation_pct">0</span>% de participation</div>
  </div>

  <!-- Bar chart -->
  <div class="chart-container" id="chart_container">
    <div class="bar-chart">
      <div class="bar-item for" id="bar_for">
        <div class="bar-label-top">
          <div class="bar-percentage" id="pct_for">0%</div>
          <div class="bar-count"><span id="count_for">0</span> voix</div>
        </div>
        <div class="bar-wrapper">
          <div class="bar" id="bar_for_fill"></div>
        </div>
        <div class="bar-label">Pour</div>
      </div>
      <div class="bar-item against" id="bar_against">
        <div class="bar-label-top">
          <div class="bar-percentage" id="pct_against">0%</div>
          <div class="bar-count"><span id="count_against">0</span> voix</div>
        </div>
        <div class="bar-wrapper">
          <div class="bar" id="bar_against_fill"></div>
        </div>
        <div class="bar-label">Contre</div>
      </div>
      <div class="bar-item abstain" id="bar_abstain">
        <div class="bar-label-top">
          <div class="bar-percentage" id="pct_abstain">0%</div>
          <div class="bar-count"><span id="count_abstain">0</span> voix</div>
        </div>
        <div class="bar-wrapper">
          <div class="bar" id="bar_abstain_fill"></div>
        </div>
        <div class="bar-label">Abstention</div>
      </div>
    </div>
  </div>

  <!-- Decision -->
  <section class="decision-section" id="decision_section">
    <div class="decision-grid">
      <div class="decision-card">
        <div class="decision-label">Decision</div>
        <div class="decision-value" id="decision_value">—</div>
        <div class="decision-detail" id="decision_detail"></div>
      </div>
      <div class="decision-card">
        <div class="decision-label">Quorum</div>
        <div class="decision-value" id="quorum_value">—</div>
        <div class="decision-detail" id="quorum_detail"></div>
      </div>
    </div>
    <span class="voter-total" id="voterTotal" hidden>
      <span id="voterTotalText">0 votants</span>
    </span>
  </section>

  <!-- Error -->
  <div class="error-box" id="error_box"></div>
</main>

<footer class="projection-footer">
  <span class="footer-brand">AG-VOTE</span>
  <span class="footer-update" id="footer_update"></span>
</footer>

<div class="sr-only" id="sr_alert" aria-live="assertive" aria-atomic="true"></div>

<script>
window.APP_API_KEY = window.APP_API_KEY
  || new URLSearchParams(location.search).get("api_key")
  || (function(){ try { return localStorage.getItem("api_key"); } catch(e){ return null; } })()
  || "";

let MEETING_ID = null;
let currentMotionId = null;

// Inject API key
(function() {
  const originalFetch = window.fetch.bind(window);
  window.fetch = function(input, init) {
    const url = (typeof input === "string") ? input : (input?.url || "");
    if (!url.includes("/api/")) return originalFetch(input, init);
    const headers = new Headers(init?.headers || {});
    if (!headers.has("X-Api-Key")) headers.set("X-Api-Key", window.APP_API_KEY);
    return originalFetch(input, { ...init, headers });
  };
})();

// Clock
function startClock() {
  const el = document.getElementById('clock');
  const update = () => {
    el.textContent = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
  };
  update();
  setInterval(update, 1000);
}

// Announce to screen reader
function announce(msg) {
  const el = document.getElementById('sr_alert');
  if (el) { el.textContent = msg; setTimeout(() => el.textContent = '', 1000); }
}

// Show/hide elements
function show(id, visible) {
  const el = document.getElementById(id);
  if (el) el.classList.toggle('visible', visible);
}

// Animate bars
function animateBars(forPct, againstPct, abstainPct, forCount, againstCount, abstainCount, forWeight, againstWeight, abstainWeight) {
  const maxHeight = 140; // max bar height in px (matches CSS .bar-wrapper height - margin)

  // Update percentages and counts
  document.getElementById('pct_for').textContent = forPct.toFixed(0) + '%';
  document.getElementById('pct_against').textContent = againstPct.toFixed(0) + '%';
  document.getElementById('pct_abstain').textContent = abstainPct.toFixed(0) + '%';

  document.getElementById('count_for').textContent = forWeight.toFixed(0);
  document.getElementById('count_against').textContent = againstWeight.toFixed(0);
  document.getElementById('count_abstain').textContent = abstainWeight.toFixed(0);

  // Animate bar heights
  requestAnimationFrame(() => {
    document.getElementById('bar_for_fill').style.height = (forPct / 100 * maxHeight) + 'px';
    document.getElementById('bar_against_fill').style.height = (againstPct / 100 * maxHeight) + 'px';
    document.getElementById('bar_abstain_fill').style.height = (abstainPct / 100 * maxHeight) + 'px';

    // Trigger label animation
    setTimeout(() => {
      document.getElementById('bar_for').classList.add('animate');
      document.getElementById('bar_against').classList.add('animate');
      document.getElementById('bar_abstain').classList.add('animate');
    }, 100);
  });
}

// Reset bars
function resetBars() {
  document.getElementById('bar_for_fill').style.height = '0';
  document.getElementById('bar_against_fill').style.height = '0';
  document.getElementById('bar_abstain_fill').style.height = '0';
  document.getElementById('bar_for').classList.remove('animate');
  document.getElementById('bar_against').classList.remove('animate');
  document.getElementById('bar_abstain').classList.remove('animate');
}

// Load results
async function loadResults(motionId, reveal = true) {
  if (!motionId) {
    show('chart_container', false);
    show('decision_section', false);
    show('secret_block', false);
    resetBars();
    return;
  }

  try {
    const res = await fetch(`/api/v1/ballots_result.php?motion_id=${encodeURIComponent(motionId)}`);
    const data = await res.json().catch(() => null);

    if (!data || data.ok === false) {
      show('chart_container', false);
      show('decision_section', false);
      return;
    }

    const d = data.data || data;
    const isSecret = !!(d.motion?.secret);
    const t = d.tallies || {};
    const quorum = d.quorum || {};
    const decision = d.decision || {};

    // Secret vote - only show participation
    if (isSecret && !reveal) {
      show('chart_container', false);
      show('decision_section', false);
      show('secret_block', true);

      const expW = d.expressed?.weight ?? 0;
      const eligW = d.eligible?.weight ?? 1;
      const pct = (expW / eligW * 100) || 0;

      document.getElementById('participation_bar').style.width = Math.min(100, pct) + '%';
      document.getElementById('participation_pct').textContent = pct.toFixed(0);
      return;
    }

    // Normal results
    show('secret_block', false);
    show('chart_container', true);
    show('decision_section', true);

    const forCount = t.for?.count ?? 0;
    const againstCount = t.against?.count ?? 0;
    const abstainCount = t.abstain?.count ?? 0;
    const forWeight = t.for?.weight ?? 0;
    const againstWeight = t.against?.weight ?? 0;
    const abstainWeight = t.abstain?.weight ?? 0;

    const totalWeight = forWeight + againstWeight + abstainWeight || 1;
    const forPct = forWeight / totalWeight * 100;
    const againstPct = againstWeight / totalWeight * 100;
    const abstainPct = abstainWeight / totalWeight * 100;

    animateBars(forPct, againstPct, abstainPct, forCount, againstCount, abstainCount, forWeight, againstWeight, abstainWeight);

    // Decision - transform technical status to user-friendly labels
    const decisionEl = document.getElementById('decision_value');
    const statusLabels = {
      'Adopte': 'Adopté',
      'Rejete': 'Rejeté',
      'no_votes': 'En attente',
      'pending': 'En cours'
    };
    const statusText = statusLabels[decision.status] || decision.status || '—';
    decisionEl.textContent = statusText;
    decisionEl.className = 'decision-value ' + (decision.status === 'Adopte' ? 'adopted' : decision.status === 'Rejete' ? 'rejected' : 'pending');

    // Hide technical reason for no_votes status
    const reasonText = decision.status === 'no_votes' ? '' : (decision.reason || '');
    document.getElementById('decision_detail').textContent = reasonText;

    // Quorum
    const quorumEl = document.getElementById('quorum_value');
    if (quorum.applied) {
      quorumEl.textContent = quorum.met ? 'Atteint' : 'Non atteint';
      quorumEl.className = 'decision-value ' + (quorum.met ? 'adopted' : 'rejected');
      document.getElementById('quorum_detail').textContent = `${(quorum.ratio ?? 0).toFixed(2)} / ${(quorum.threshold ?? 0).toFixed(2)}`;
    } else {
      quorumEl.textContent = 'N/A';
      quorumEl.className = 'decision-value pending';
      document.getElementById('quorum_detail').textContent = '';
    }

  } catch (e) {
    console.error('loadResults error:', e);
  }
}

// Update resolution text box
function updateResolution(motionData) {
  const box = document.getElementById('resolution_box');
  const text = document.getElementById('resolution_text');
  const num = document.getElementById('motion_number');

  if (!motionData) {
    show('resolution_box', false);
    if (num) num.textContent = '';
    return;
  }

  // Motion number
  if (num) {
    num.textContent = motionData.position ? 'Resolution n\u00b0' + motionData.position : '';
  }

  // Resolution body text
  const content = motionData.body || motionData.description || '';
  if (content) {
    text.textContent = content;
    show('resolution_box', true);
  } else {
    show('resolution_box', false);
  }
}

// Update footer timestamp
function updateTimestamp() {
  const el = document.getElementById('footer_update');
  if (el) {
    el.textContent = 'Mis \u00e0 jour : ' + new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }
}

// Refresh screen
async function refresh() {
  const badge = document.getElementById('badge');
  const meet = document.getElementById('meeting_title');
  const motion = document.getElementById('motion_title');
  const sub = document.getElementById('motion_sub');
  const err = document.getElementById('error_box');

  try {
    const res = await fetch('/api/v1/projector_state.php');
    const data = await res.json();

    if (!data.ok) {
      if (data.error === 'no_live_meeting') {
        badge.className = 'status-badge off';
        badge.textContent = 'hors seance';
        meet.textContent = '';
        motion.textContent = 'Aucune seance en cours';
        sub.textContent = '';
        err.classList.remove('visible');
        show('waiting_state', false);
        show('chart_container', false);
        show('decision_section', false);
        show('secret_block', false);
        updateResolution(null);
        resetBars();
        updateTimestamp();
        return;
      }
      throw new Error(data.error || 'Erreur inconnue');
    }

    const s = data.data;
    err.classList.remove('visible');
    meet.textContent = s.meeting_title || '';
    MEETING_ID = s.meeting_id;

    if (s.phase === 'active' && s.motion?.id) {
      // Vote in progress
      badge.className = 'status-badge live';
      badge.textContent = 'vote en cours';
      motion.textContent = s.motion.title || 'Resolution';
      sub.textContent = s.motion.secret ? 'Vote secret' : '';
      show('waiting_state', false);
      updateResolution(s.motion);

      if (currentMotionId !== s.motion.id) {
        resetBars();
        currentMotionId = s.motion.id;
      }

      await loadResults(s.motion.id, !s.motion.secret);

    } else if (s.phase === 'closed' && s.motion?.id) {
      // Final result
      badge.className = 'status-badge idle';
      badge.textContent = 'resultat';
      motion.textContent = s.motion.title || 'Resolution';
      sub.textContent = 'Resultat final';
      show('waiting_state', false);
      updateResolution(s.motion);

      if (currentMotionId !== s.motion.id) {
        resetBars();
        currentMotionId = s.motion.id;
      }

      await loadResults(s.motion.id, true);

    } else {
      // Waiting
      badge.className = 'status-badge idle';
      badge.textContent = 'en seance';
      motion.textContent = 'En attente';
      sub.textContent = '';
      show('waiting_state', true);
      show('chart_container', false);
      show('decision_section', false);
      show('secret_block', false);
      updateResolution(null);
      currentMotionId = null;
      resetBars();
    }

    updateTimestamp();

  } catch (e) {
    console.error('refresh error:', e);
    err.textContent = 'Erreur : ' + e.message;
    err.classList.add('visible');
  }
}

// Heartbeat
function getDeviceId() {
  try {
    let id = localStorage.getItem('device.id');
    if (!id) { id = crypto?.randomUUID?.() || `${Date.now()}-${Math.random().toString(16).slice(2)}`; localStorage.setItem('device.id', id); }
    return id;
  } catch { return `anon-${Date.now()}`; }
}

async function heartbeat() {
  if (!MEETING_ID) return;
  try {
    await fetch('/api/v1/device_heartbeat.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ meeting_id: MEETING_ID, device_id: getDeviceId(), role: 'projector' })
    });
  } catch {}
}

// Init
document.addEventListener('DOMContentLoaded', () => {
  startClock();
  refresh();
  setInterval(refresh, 3000);
  heartbeat();
  setInterval(() => { if (!document.hidden) heartbeat(); }, 15000);
});
</script>

</body>
</html>
