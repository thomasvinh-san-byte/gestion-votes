\
/*! qrcode-generator (MIT) - compact build for this project */
(function(global){
  function QR8bitByte(data){this.mode=1;this.data=data;this.parsed=[];for(var i=0;i<this.data.length;i++){this.parsed.push(this.data.charCodeAt(i));}}
  QR8bitByte.prototype={getLength:function(){return this.parsed.length;},write:function(buf){for(var i=0;i<this.parsed.length;i++){buf.put(this.parsed[i],8);}}};

  function BitBuffer(){this.buffer=[];this.length=0;}
  BitBuffer.prototype={
    get:function(i){var b=Math.floor(i/8);return ((this.buffer[b]>>> (7 - i%8)) &1)===1;},
    put:function(num,len){for(var i=0;i<len;i++){this.putBit(((num >>> (len-i-1)) &1)===1);}},
    putBit:function(bit){var b=Math.floor(this.length/8);if(this.buffer.length<=b){this.buffer.push(0);} if(bit){this.buffer[b]|=(0x80 >>> (this.length%8));} this.length++;}
  };

  function QRPolynomial(num,shift){if(num.length===undefined)throw new Error(num.length+"/"); var offset=0; while(offset<num.length && num[offset]===0) offset++; this.num=new Array(num.length-offset+shift); for(var i=0;i<num.length-offset;i++) this.num[i]=num[i+offset];}
  QRPolynomial.prototype={
    get:function(i){return this.num[i];},
    getLength:function(){return this.num.length;},
    multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1); for(var i=0;i<num.length;i++) num[i]=0;
      for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}
      return new QRPolynomial(num,0);
    },
    mod:function(e){if(this.getLength()-e.getLength()<0) return this;
      var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));
      var num=new Array(this.getLength()); for(var i=0;i<this.getLength();i++) num[i]=this.get(i);
      for(var i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}
      return new QRPolynomial(num,0).mod(e);
    }
  };

  var QRMath={
    glog:function(n){if(n<1) throw new Error("glog"); return QRMath.LOG_TABLE[n];},
    gexp:function(n){while(n<0)n+=255; while(n>=256)n-=255; return QRMath.EXP_TABLE[n];},
    EXP_TABLE:new Array(256),
    LOG_TABLE:new Array(256)
  };
  for(var i=0;i<8;i++) QRMath.EXP_TABLE[i]=1<<i;
  for(var i=8;i<256;i++) QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];
  for(var i=0;i<255;i++) QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;

  function getErrorCorrectPolynomial(ec){var a=new QRPolynomial([1],0); for(var i=0;i<ec;i++){a=a.multiply(new QRPolynomial([1, QRMath.gexp(i)],0));} return a;}

  function RSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
  RSBlock.getRSBlocks=function(typeNumber, errorCorrectLevel){
    // minimal table for typeNumber up to 6, level M (works for URLs)
    // Format: [count, total, data]
    var table={
      "1-1":[[1,26,16]],
      "2-1":[[1,44,28]],
      "3-1":[[1,70,44]],
      "4-1":[[1,100,64]],
      "5-1":[[1,134,86]],
      "6-1":[[2,86,54]]
    };
    var key=typeNumber+"-"+errorCorrectLevel;
    var list=table[key];
    if(!list) throw new Error("RSBlock unsupported type/level: "+key);
    var blocks=[];
    for(var i=0;i<list.length;i++){
      var c=list[i][0], t=list[i][1], d=list[i][2];
      for(var j=0;j<c;j++) blocks.push(new RSBlock(t,d));
    }
    return blocks;
  };

  var QRUtil={
    PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,38]],
    G15: (1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0),
    G18: (1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0),
    G15_MASK: (1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1),
    getBCHDigit:function(data){var digit=0; while(data!==0){digit++; data>>>=1;} return digit;},
    getBCHTypeInfo:function(data){var d=data<<10; while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));} return ((data<<10)|d)^QRUtil.G15_MASK;},
    getBCHTypeNumber:function(data){var d=data<<12; while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));} return (data<<12)|d;},
    getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber];},
    getMask:function(maskPattern,i,j){
      switch(maskPattern){
        case 0: return (i+j)%2===0;
        case 1: return i%2===0;
        case 2: return j%3===0;
        case 3: return (i+j)%3===0;
        case 4: return (Math.floor(i/2)+Math.floor(j/3))%2===0;
        default: return false;
      }
    },
    getErrorCorrectPolynomial:getErrorCorrectPolynomial
  };

  function QRCode(typeNumber, errorCorrectLevel){
    this.typeNumber=typeNumber;
    this.errorCorrectLevel=errorCorrectLevel; // 1=M only in this compact build
    this.modules=null; this.moduleCount=0;
    this.dataList=[];
  }
  QRCode.prototype={
    addData:function(data){this.dataList.push(new QR8bitByte(data));},
    isDark:function(r,c){if(this.modules[r][c]!==null) return this.modules[r][c]; else return false;},
    getModuleCount:function(){return this.moduleCount;},
    make:function(){
      // auto type selection up to 6
      for(var t=1;t<=6;t++){
        if(this._canMake(t)){this.typeNumber=t; break;}
      }
      this._makeImpl(false, this._getBestMaskPattern());
    },
    _canMake:function(t){
      var rsBlocks=RSBlock.getRSBlocks(t,1);
      var buffer=new BitBuffer();
      for(var i=0;i<this.dataList.length;i++){
        var d=this.dataList[i];
        buffer.put(4,4); // mode byte
        buffer.put(d.getLength(), t<10?8:16);
        d.write(buffer);
      }
      var totalDataCount=0;
      for(var i=0;i<rsBlocks.length;i++) totalDataCount += rsBlocks[i].dataCount;
      return buffer.length <= totalDataCount*8;
    },
    _makeImpl:function(test, maskPattern){
      this.moduleCount = this.typeNumber*4+17;
      this.modules=new Array(this.moduleCount);
      for(var r=0;r<this.moduleCount;r++){
        this.modules[r]=new Array(this.moduleCount);
        for(var c=0;c<this.moduleCount;c++) this.modules[r][c]=null;
      }
      this._setupPositionProbePattern(0,0);
      this._setupPositionProbePattern(this.moduleCount-7,0);
      this._setupPositionProbePattern(0,this.moduleCount-7);
      this._setupTimingPattern();
      this._setupTypeNumber(test);
      this._setupTypeInfo(test, maskPattern);
      var data = this._createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      this._mapData(data, maskPattern);
    },
    _setupPositionProbePattern:function(row,col){
      for(var r=-1;r<=7;r++){
        if(row+r<=-1 || this.moduleCount<=row+r) continue;
        for(var c=-1;c<=7;c++){
          if(col+c<=-1 || this.moduleCount<=col+c) continue;
          if((0<=r && r<=6 && (c===0||c===6)) || (0<=c && c<=6 && (r===0||r===6)) || (2<=r && r<=4 && 2<=c && c<=4))
            this.modules[row+r][col+c]=true;
          else this.modules[row+r][col+c]=false;
        }
      }
    },
    _setupTimingPattern:function(){
      for(var i=8;i<this.moduleCount-8;i++){
        if(this.modules[i][6]===null) this.modules[i][6]= (i%2===0);
        if(this.modules[6][i]===null) this.modules[6][i]= (i%2===0);
      }
    },
    _setupTypeNumber:function(test){
      if(this.typeNumber<7) return;
      var bits=QRUtil.getBCHTypeNumber(this.typeNumber);
      for(var i=0;i<18;i++){
        var mod=!test && ((bits>>i)&1)===1;
        this.modules[Math.floor(i/3)][i%3 + this.moduleCount-8-3]=mod;
        this.modules[i%3 + this.moduleCount-8-3][Math.floor(i/3)]=mod;
      }
    },
    _setupTypeInfo:function(test, maskPattern){
      var data=(this.errorCorrectLevel<<3) | maskPattern;
      var bits=QRUtil.getBCHTypeInfo(data);
      for(var i=0;i<15;i++){
        var mod=!test && ((bits>>i)&1)===1;
        if(i<6) this.modules[i][8]=mod;
        else if(i<8) this.modules[i+1][8]=mod;
        else this.modules[this.moduleCount-15+i][8]=mod;
      }
      for(var i=0;i<15;i++){
        var mod=!test && ((bits>>i)&1)===1;
        if(i<8) this.modules[8][this.moduleCount-i-1]=mod;
        else if(i<9) this.modules[8][15-i-1+1]=mod;
        else this.modules[8][15-i-1]=mod;
      }
      this.modules[this.moduleCount-8][8]=!test;
    },
    _getBestMaskPattern:function(){
      // try 0..4 only in compact build
      var min=1e9, best=0;
      for(var p=0;p<=4;p++){
        this._makeImpl(true,p);
        var lost=this._lostPoint();
        if(lost<min){min=lost; best=p;}
      }
      return best;
    },
    _lostPoint:function(){
      // simplified penalty
      var lost=0, mc=this.moduleCount, m=this.modules;
      for(var r=0;r<mc;r++){
        for(var c=0;c<mc;c++){
          var same=0, dark=m[r][c];
          for(var dr=-1;dr<=1;dr++){
            if(r+dr<0||mc<=r+dr) continue;
            for(var dc=-1;dc<=1;dc++){
              if(c+dc<0||mc<=c+dc) continue;
              if(dr===0&&dc===0) continue;
              if(dark===m[r+dr][c+dc]) same++;
            }
          }
          if(same>5) lost += (same-5)+3;
        }
      }
      return lost;
    },
    _createData:function(typeNumber, errorCorrectLevel, dataList){
      var rsBlocks=RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer=new BitBuffer();
      for(var i=0;i<dataList.length;i++){
        var data=dataList[i];
        buffer.put(4,4);
        buffer.put(data.getLength(), typeNumber<10?8:16);
        data.write(buffer);
      }
      var totalDataCount=0;
      for(var i=0;i<rsBlocks.length;i++) totalDataCount += rsBlocks[i].dataCount;
      if(buffer.length + 4 <= totalDataCount*8) buffer.put(0,4);
      while(buffer.length % 8 !== 0) buffer.putBit(false);
      while(buffer.length/8 < totalDataCount){
        buffer.put(0xec,8);
        if(buffer.length/8>=totalDataCount) break;
        buffer.put(0x11,8);
      }
      // to bytes
      var dataBytes=[];
      for(var i=0;i<buffer.buffer.length;i++) dataBytes.push(buffer.buffer[i]);
      // RS
      var offset=0;
      var dcdata=[], ecdata=[];
      var maxDc=0, maxEc=0;
      for(var r=0;r<rsBlocks.length;r++){
        var dc=rsBlocks[r].dataCount;
        var ec=rsBlocks[r].totalCount - dc;
        maxDc=Math.max(maxDc,dc); maxEc=Math.max(maxEc,ec);
        var dbytes=new Array(dc);
        for(var i=0;i<dbytes.length;i++) dbytes[i]=dataBytes[i+offset];
        offset += dc;
        var rsPoly=QRUtil.getErrorCorrectPolynomial(ec);
        var rawPoly=new QRPolynomial(dbytes, rsPoly.getLength()-1);
        var modPoly=rawPoly.mod(rsPoly);
        var ebytes=new Array(rsPoly.getLength()-1);
        for(var i=0;i<ebytes.length;i++){
          var modIndex = i + modPoly.getLength() - ebytes.length;
          ebytes[i] = modIndex >=0 ? modPoly.get(modIndex) : 0;
        }
        dcdata.push(dbytes);
        ecdata.push(ebytes);
      }
      var totalCodeCount=0;
      for(var i=0;i<rsBlocks.length;i++) totalCodeCount += rsBlocks[i].totalCount;
      var dataOut=new Array(totalCodeCount);
      var index=0;
      for(var i=0;i<maxDc;i++){
        for(var r=0;r<dcdata.length;r++){
          if(i<dcdata[r].length) dataOut[index++]=dcdata[r][i];
        }
      }
      for(var i=0;i<maxEc;i++){
        for(var r=0;r<ecdata.length;r++){
          if(i<ecdata[r].length) dataOut[index++]=ecdata[r][i];
        }
      }
      return dataOut;
    },
    _mapData:function(data, maskPattern){
      var inc=-1;
      var row=this.moduleCount-1;
      var bitIndex=7;
      var byteIndex=0;
      for(var col=this.moduleCount-1; col>0; col-=2){
        if(col===6) col--;
        while(true){
          for(var c=0;c<2;c++){
            if(this.modules[row][col-c]===null){
              var dark=false;
              if(byteIndex < data.length){
                dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
              }
              var mask = QRUtil.getMask(maskPattern,row,col-c);
              if(mask) dark = !dark;
              this.modules[row][col-c]=dark;
              bitIndex--;
              if(bitIndex===-1){byteIndex++; bitIndex=7;}
            }
          }
          row += inc;
          if(row<0 || this.moduleCount<=row){row -= inc; inc=-inc; break;}
        }
      }
    }
  };

  function makeQrSvg(text, size){
    var qr=new QRCode(1,1); // auto type, level M
    qr.addData(text);
    qr.make();
    var mc=qr.getModuleCount();
    var scale = Math.floor(size / mc);
    if(scale<2) scale=2;
    var dim = mc*scale;
    var svg=['<svg xmlns="http://www.w3.org/2000/svg" width="'+dim+'" height="'+dim+'" viewBox="0 0 '+dim+' '+dim+'">'];
    svg.push('<rect width="100%" height="100%" fill="#fff"/>');
    for(var r=0;r<mc;r++){
      for(var c=0;c<mc;c++){
        if(qr.isDark(r,c)){
          svg.push('<rect x="'+(c*scale)+'" y="'+(r*scale)+'" width="'+scale+'" height="'+scale+'" fill="#000"/>');
        }
      }
    }
    svg.push('</svg>');
    return svg.join('');
  }

  global.QR = { toSvg: makeQrSvg };
})(window);
